from machine import Pin
from utime import sleep, ticks_ms, ticks_diff
import time
import neopixel
import random as rand
import rp2
from rp2 import PIO

# ---Setup---
# Game states
IDLE         = 0
RUNNING      = 1
ENDING       = 2
ENDED        = 3
DISCONNECTED = 4

# NeoPixel variables
NUM_PIXELS = 16             # Number of LED:s in rings
NP1_PIN    = 16             # Pin for the first ring
NP2_PIN    = 17             # Pin for the second ring
NP3_PIN    = 18             # Pin for the third ring
NP4_PIN    = 19             # Pin for the fourth ring
NP5_PIN    = 20             # Pin for the fifth ring
WHITE      = (123,123,123)  # RGB-values of different colours
BLACK      = (0,0,0)
RED        = (123,0,0)
GREEN      = (0,123,0)
BLUE       = (0,0,123)
YELLOW     = (123,123,0)

TIME_FLOOR = 5    # Shortest time (seconds) before a pin is chosen
TIME_ROOF  = 15   # Longest time (seconds) before a pin is chosen

DEBOUNCE_TIME = 50 # Debounce time for button press (milliseconds)

# With shift register 
#DATA_PIN      = 0
#CLOCK_PIN     = 1
#LATCH_PIN     = 26
#NUM_BITS      = 5
#NUM_SIG_BITS  = 5
#data = Pin(DATA_PIN, Pin.IN)
#clock = Pin(CLOCK_PIN, Pin.OUT)
#latch = Pin(LATCH_PIN, Pin.OUT)

# Without shift register
RS1_PIN = 21  # Pin numbers for the Reed switches
RS2_PIN = 22
RS3_PIN = 26
RS4_PIN = 27
RS5_PIN = 28
rs1 = Pin(RS1_PIN, Pin.IN, Pin.PULL_DOWN) # Pins initialized as pull-down to ensure low when rod is removed
rs2 = Pin(RS2_PIN, Pin.IN, Pin.PULL_DOWN)
rs3 = Pin(RS3_PIN, Pin.IN, Pin.PULL_DOWN)
rs4 = Pin(RS4_PIN, Pin.IN, Pin.PULL_DOWN)
rs5 = Pin(RS5_PIN, Pin.IN, Pin.PULL_DOWN)
rs_list = [rs1, rs2, rs3, rs4, rs5] # List of all Reed switches

high_score  = 0 # Not used in current implementation
btn_pressed = 0
control_sig = 0
last_interrupt = 0

np1 = neopixel.NeoPixel(Pin(NP1_PIN), NUM_PIXELS)
np2 = neopixel.NeoPixel(Pin(NP2_PIN), NUM_PIXELS)
np3 = neopixel.NeoPixel(Pin(NP3_PIN), NUM_PIXELS)
np4 = neopixel.NeoPixel(Pin(NP4_PIN), NUM_PIXELS)
np5 = neopixel.NeoPixel(Pin(NP5_PIN), NUM_PIXELS)
for i in range(NUM_PIXELS): # Initializes all NP rings to black (off)
  np1[i] = BLACK
  np2[i] = BLACK
  np3[i] = BLACK
  np4[i] = BLACK
  np5[i] = BLACK
np_list = [np1, np2, np3, np4, np5] # List of all NP rings

btn_pin = Pin(15, Pin.IN, Pin.PULL_UP)
btn_LED = Pin(14, Pin.OUT)

# ---Beginning of SevSeg---
@rp2.asm_pio(out_init=[PIO.OUT_LOW]*8, sideset_init=[PIO.OUT_LOW]*4) 
def sevseg():
  wrap_target()
  label("0")
  pull(noblock)  .side(0b1111)  # Pull data into OSR, don't block if FIFO is empty
  mov(x, osr)    .side(0b1111)  # Move data from OSR to `x` scratch register
  nop()          .side(0b1111)
  out(pins, 8)   .side(0b1110)
  nop()          .side(0b1111)
  out(pins, 8)   .side(0b1101)
  nop()          .side(0b1111)
  out(pins, 8)   .side(0b1011)
  nop()          .side(0b1111)
  out(pins, 8)   .side(0b0111)
  nop()          .side(0b1111)
  jmp("0")       .side(0b1111)  # Jump to label("0")
  wrap()
  
sm = rp2.StateMachine(0, sevseg, freq=2000, out_base=Pin(2), sideset_base=Pin(10))
#sm.active(1) # Uncomment to start the Seven Segment display

digits = [
  0b00111111, # 0
  0b00000110, # 1
  0b01011011, # 2 
  0b01001111, # 3
  0b01100110, # 4
  0b01101101, # 5
  0b01111101, # 6
  0b00000111, # 7
  0b01111111, # 8
  0b01100111, # 9
]

second_digits = [
  0b10111111, # 0
  0b10000110, # 1
  0b11011011, # 2 
  0b11001111, # 3
  0b11100110, # 4
  0b11101101, # 5
  0b11111101, # 6
  0b10000111, # 7
  0b11111111, # 8
  0b11100111, # 9
]

def segmentize(num):
  return (
    digits[num % 10] 
    | digits[num // 10 % 10] << 8
    | digits[num // 100 % 10] << 16 
    | digits[num // 1000 % 10] << 24 
  )
# ---End of SevSeg---

# Helper functions
def non_blocking_sleep(milliseconds): # Does not prevent interrupts, should replace sleep() in most cases
  start_time = ticks_ms()  # Get the current time in milliseconds
  while ticks_diff(ticks_ms(), start_time) < milliseconds:
    if control_sig == 1 and game_state == ENDED: # Needed for rs_interrupt to work as intended
      break

def write_colour(np, colour): # Writes one colour to a selected NP ring
  for i in range(NUM_PIXELS):
    np[i] = colour
  np.write()

def write_colour_all(colour): # Writes the same colour to all NP rings
  for np in np_list:
    write_colour(np, colour)

def btn_interrupt(pin): # Handles interrupts generated by button presses
  global btn_pressed, last_interrupt
  curr_time = ticks_ms()
  if ticks_diff(curr_time, last_interrupt) < DEBOUNCE_TIME: # Software solution to button debouncing
    pass
  elif btn_pressed == 0:
    btn_pressed = 1
  last_interrupt = curr_time  # Record last interrupt for debouncing purposes
btn_pin.irq(trigger=Pin.IRQ_FALLING, handler=btn_interrupt) # Assigns the interrupt handler to the button

def rs_interrupt(pin): # Handles interrupts generated by Reed switches
  global game_state, control_sig
  if game_state == RUNNING:
    write_colour_all(RED)
    game_state = ENDED
    non_blocking_sleep(2000)
    control_sig = 1
rs1.irq(trigger=Pin.IRQ_FALLING, handler=rs_interrupt)
rs2.irq(trigger=Pin.IRQ_FALLING, handler=rs_interrupt)
rs3.irq(trigger=Pin.IRQ_FALLING, handler=rs_interrupt)
rs4.irq(trigger=Pin.IRQ_FALLING, handler=rs_interrupt)
rs5.irq(trigger=Pin.IRQ_FALLING, handler=rs_interrupt)

def assess_connection(): # Checks the connection of the rods. If any are disconnected, light them up in yellow
  for rs in rs_list:
    if rs.value() == 0:
      write_colour(np_list[rs_list.index(rs)], YELLOW)
    else:
      write_colour(np_list[rs_list.index(rs)], GREEN)

# ATTENTION: Use only one of the following functions (asses_choice), depending on if a shift register is used or not
def assess_choice(choice): # Checks the output directly from the Reed switches to detect if the correct rod is removed
  global control_sig
  for rs in rs_list:
    if rs.value() == 0:
      if rs_list.index(rs) == choice-1:
        control_sig = 1
        write_colour(np_list[choice-1], GREEN)
      else:
        write_colour(np_list[rs_list.index(rs)], RED)
'''
def assess_choice_sr(choice): # Samples the shift register to detect if the correct rod is removed
  global control_sig
  # Step 1: Sample the current data by flipping the latch pin
  latch.value(0)
  latch.value(1)
  # Step 2: Check if any rods have been removed
  for i in range(NUM_BITS):
    bit = data.value()
    # Step 3: Check if the bit is one we are concerned about
    if i < NUM_SIG_BITS:
      #test_LED_list[i].value(bit)
      # Step 4: Check if the correct rod was removed
      if bit == 1: # ATTENTION: bit == 1 should be bit == 0 in actual implementation
        if i == choice-1:
          control_sig = 1 # If correct, game can proceed
          write_colour(np_list[i], GREEN)
        else:
          write_colour(np_list[i], RED) 
    # Step 5: Flip the clock to shift to next bit
    clock.value(1)
    clock.value(0)
'''
sm.put(segmentize(0)) # Initializes the SevSeg display with 0 on all digits
game_state = IDLE # Initializes the game to the IDLE state
btn_LED.value(1)  # Turns on the button LED to indicate the game is ready

# Main loop
while True:   # Will loop forever when the Pi is powered
  if game_state == IDLE:
    # Logic for the game's idle state
    for np in np_list:
      # Check if button has been pressed
      if btn_pressed == 1:
        btn_LED.value(0)
        if rs1.value() == 1 and rs2.value() == 1 and rs3.value() == 1 and rs4.value() == 1 and rs5.value() == 1:
          game_state = RUNNING
          break
        else:
          game_state = DISCONNECTED
          break
      else: # Do idle animation to show game is ready
        write_colour(np, WHITE)
        non_blocking_sleep(500)
        write_colour(np, BLACK)
        non_blocking_sleep(500)

  elif game_state == DISCONNECTED:
    # Logic for the game's disconnected state
    assess_connection()
    if rs1.value() == 1 and rs2.value() == 1 and rs3.value() == 1 and rs4.value() == 1 and rs5.value() == 1:
      write_colour_all(GREEN)
      game_state = RUNNING
      non_blocking_sleep(3000)
    
  elif game_state == RUNNING:
    # Logic for running the game
    write_colour_all(WHITE)
    rand_time = rand.randrange(TIME_FLOOR, TIME_ROOF)
    non_blocking_sleep(rand_time*1000)
    if control_sig != 1:
      rand_choice = rand.randrange(1, 5)
      write_colour(np_list[rand_choice-1], BLACK)
      game_state = ENDING

  elif game_state == ENDING:
    # Logic for ending the game (measuring reaction time, assessing rod choice, etc.)
    time_out = False
    start_time = ticks_ms()
    while control_sig != 1:
      assess_choice(rand_choice)
      if ticks_diff(ticks_ms(), start_time) > 9999:
        time_out = True
        break
    control_sig = 0
    if not time_out:
      reaction_speed = ticks_diff(ticks_ms(), start_time)
      print(reaction_speed)
      sm.put(segmentize(reaction_speed))
      if reaction_speed > high_score:
        # Write logic for transferring score to central hub here, if implemented
        high_score = reaction_speed
    else:
      sm.put(segmentize(9999)) # Display 9.999 as standard value indicating time out
    game_state = ENDED
    sleep(10)

  elif game_state == ENDED:
    # Logic for ending the game (resetting everything to appropriate values)
    control_sig = 0
    write_colour_all(BLACK)
    sm.put(segmentize(0))
    non_blocking_sleep(500)
    game_state = IDLE
    btn_pressed = 0
    btn_LED.value(1)

  else:
    # Error logic goes here, being here indicates failure in the game's state machine, restart recommended
    write_colour_all(RED)
    sleep(0.5)
    write_colour_all(BLACK)
    sleep(0.5)
